import Mathlib.LinearAlgebra.Matrix.Defs
import Mathlib.LinearAlgebra.Matrix.Notation
import Mathlib.Data.Complex.Basic
import Mathlib.Tactic
import Mathlib.Algebra.Group.Defs
import Mathlib.Algebra.Group.Subgroup.Basic
import ShorsCode.Foundations.Foundations
import ShorsCode.Stabilizer.PauliGroupSingle
import ShorsCode.Stabilizer.PauliGroup

namespace Quantum
open Matrix
open scoped BigOperators
open NQubitPauliGroupElement
open NQubitPauliOperator

variable {n : ℕ}

/-!
# Stabilizer Groups

This file defines stabilizer groups, which are abelian subgroups of the n-qubit Pauli group
that do not contain -I. Stabilizer groups are fundamental to the stabilizer formalism for
quantum error correction.

A stabilizer group stabilizes a quantum state (or subspace) by consisting of all Pauli group
elements that fix that state with eigenvalue +1.

## Key Properties

- **Abelian**: All elements in a stabilizer group commute with each other
- **No -I**: The negative identity is excluded (it would stabilize no states)
- **Subgroup structure**: Forms a subgroup of the n-qubit Pauli group
- **Codespace**: The set of states stabilized by all elements in the group forms the codespace
- **Generators**: For an n-qubit system, a stabilizer group can have at most n
independent generators

## Example

For the 3-qubit bit-flip repetition code, the stabilizer group is generated by:
- Z₁Z₂ (Z on qubits 1 and 2, I on qubit 3)
- Z₂Z₃ (I on qubit 1, Z on qubits 2 and 3)

This stabilizes the codespace spanned by |000⟩ and |111⟩.
-/

/-- The negative identity element: -I ⊗ I ⊗ ... ⊗ I.

This is the n-qubit Pauli group element with phase -1 (phasePower = 2, since
phasePower 2 corresponds to i^2 = -1) and identity operators on all qubits.

This element is excluded from stabilizer groups because it would stabilize no states
(every state would be mapped to its negative, not itself).
-/
def negIdentity (n : ℕ) : NQubitPauliGroupElement n :=
  ⟨2, NQubitPauliOperator.identity n⟩

@[simp] lemma negIdentity_phasePower (n : ℕ) : (negIdentity n).phasePower = 2 := rfl

@[simp] lemma negIdentity_operators (n : ℕ) :
  (negIdentity n).operators = NQubitPauliOperator.identity n := rfl

/-!
# Stabilized States

A quantum state is stabilized by a Pauli group element if applying that element
to the state leaves it unchanged (i.e., the state is an eigenvector
with eigenvalue +1).
-/

/-- A vector is stabilized by a Pauli group element if applying the element's matrix
    representation to the vector returns the same vector.

    This means the vector is an eigenvector with eigenvalue +1.
-/
def IsStabilizedVec (g : NQubitPauliGroupElement n) (v : NQubitVec n) : Prop :=
  Matrix.mulVec (g.toMatrix) v = v

/-- A quantum state is stabilized by a Pauli group element if its underlying vector
    is stabilized by that element.

    This means applying the Pauli group element to the state returns the same state.
-/
def IsStabilizedBy (g : NQubitPauliGroupElement n) (ψ : NQubitState n) : Prop :=
  IsStabilizedVec g ψ.val

/-- A stabilizer group is an abelian subgroup of the n-qubit Pauli group that does not contain -I.

Properties:
- It is a subgroup of the n-qubit Pauli group
- It is abelian (all elements commute)
- It does not contain -I
- For an n-qubit system, a stabilizer group can have at most n independent generators
-/
structure StabilizerGroup (n : ℕ) where
  /-- The underlying subgroup of the n-qubit Pauli group. -/
  toSubgroup : Subgroup (NQubitPauliGroupElement n)
  /-- The subgroup is abelian: all elements commute. -/
  is_abelian : ∀ (g h : NQubitPauliGroupElement n) (_ : g ∈ toSubgroup) (_ : h ∈ toSubgroup),
    g * h = h * g
  /-- The stabilizer does not contain -I. -/
  no_neg_identity : negIdentity n ∉ toSubgroup

namespace StabilizerGroup

/-- Coerce a stabilizer group to its underlying subgroup. -/
instance : Coe (StabilizerGroup n) (Subgroup (NQubitPauliGroupElement n)) :=
  ⟨StabilizerGroup.toSubgroup⟩

/-- A quantum state is in the codespace of a stabilizer group if it is stabilized
    by every element in the group.

    The codespace of a stabilizer group consists of all states stabilized by that group.
-/
def IsInCodespace (ψ : NQubitState n) (S : StabilizerGroup n) : Prop :=
  ∀ g ∈ S.toSubgroup, IsStabilizedBy g ψ

/-- The identity element is in every stabilizer group. -/
lemma one_mem (S : StabilizerGroup n) : (1 : NQubitPauliGroupElement n) ∈ S.toSubgroup :=
  S.toSubgroup.one_mem

/-- If g and h are in a stabilizer group, then g * h is also in it. -/
lemma mul_mem (S : StabilizerGroup n) {g h : NQubitPauliGroupElement n}
  (hg : g ∈ S.toSubgroup) (hh : h ∈ S.toSubgroup) : g * h ∈ S.toSubgroup :=
  S.toSubgroup.mul_mem hg hh

/-- If g is in a stabilizer group, then g⁻¹ is also in it. -/
lemma inv_mem (S : StabilizerGroup n) {g : NQubitPauliGroupElement n}
  (hg : g ∈ S.toSubgroup) : g⁻¹ ∈ S.toSubgroup :=
  S.toSubgroup.inv_mem hg

/-- All elements of a stabilizer group commute. -/
lemma commutes (S : StabilizerGroup n) {g h : NQubitPauliGroupElement n}
  (hg : g ∈ S.toSubgroup) (hh : h ∈ S.toSubgroup) : g * h = h * g :=
  S.is_abelian g h hg hh

/-- The negative identity is not in any stabilizer group. -/
lemma neg_identity_not_mem (S : StabilizerGroup n) : negIdentity n ∉ S.toSubgroup :=
  S.no_neg_identity

/-!
# Helper Lemmas for Constructing Stabilizer Groups

These lemmas make it easier to prove that a subgroup is abelian when constructing
a `StabilizerGroup`.
-/

/-!
# Basic Properties of Stabilized States
-/

/-- The identity element stabilizes all vectors. -/
lemma identity_stabilizes_vec (v : NQubitVec n) :
  IsStabilizedVec (1 : NQubitPauliGroupElement n) v := by
  simp only [IsStabilizedVec]
  rw [NQubitPauliGroupElement.toMatrix_one, one_mulVec]


/-- The identity element stabilizes all quantum states. -/
lemma identity_stabilizes (ψ : NQubitState n) : IsStabilizedBy (1 : NQubitPauliGroupElement n) ψ :=
  identity_stabilizes_vec ψ.val

/-- If a state is in the codespace of a stabilizer group, then it is stabilized by the identity. -/
lemma IsInCodespace.identity_stabilizes (ψ : NQubitState n) (S : StabilizerGroup n)
  (h : IsInCodespace ψ S) : IsStabilizedBy (1 : NQubitPauliGroupElement n) ψ := by
  have h_one : (1 : NQubitPauliGroupElement n) ∈ S.toSubgroup := S.one_mem
  exact h (1 : NQubitPauliGroupElement n) h_one

/-!
# Properties of Stabilized States

These lemmas show how stabilization behaves under group operations, which is crucial
for working with stabilizer groups and codespaces.
-/

/-- If a state is stabilized by g and h, then it is stabilized by g * h.

This follows from the fact that if g and h both fix a vector v, then their product
also fixes v: (g * h) • v = g • (h • v) = g • v = v.
-/
lemma IsStabilizedBy.mul {g h : NQubitPauliGroupElement n} {v : NQubitVec n}
  (hg : IsStabilizedVec g v) (hh : IsStabilizedVec h v) :
  IsStabilizedVec (g * h) v := by
  simp only [IsStabilizedVec, toMatrix_mul] at *
  have h : (g.toMatrix * h.toMatrix) *ᵥ v = g.toMatrix *ᵥ (h.toMatrix *ᵥ v) := by
    exact Eq.symm (mulVec_mulVec v g.toMatrix h.toMatrix)
  rw [h, hh, hg]

/-- If a state is stabilized by g, then it is stabilized by g⁻¹.

This follows from the fact that if g fixes v, then g⁻¹ also fixes v:
g⁻¹ • v = g⁻¹ • (g • v) = (g⁻¹ * g) • v = 1 • v = v.
-/
lemma IsStabilizedBy.inv {g : NQubitPauliGroupElement n} {v : NQubitVec n}
  (hg : IsStabilizedVec g v) :
  IsStabilizedVec (g⁻¹) v := by
  simp [IsStabilizedVec] at hg ⊢
  -- Apply `(g⁻¹).toMatrix` to the stabilization equation `g.toMatrix *ᵥ v = v`.
  have h_apply :
      (g⁻¹).toMatrix *ᵥ (g.toMatrix *ᵥ v) = (g⁻¹).toMatrix *ᵥ v := by
    simp [hg]
  -- Reassociate using `mulVec_mulVec`.
  have h_assoc :
      ((g⁻¹).toMatrix * g.toMatrix) *ᵥ v = (g⁻¹).toMatrix *ᵥ (g.toMatrix *ᵥ v) := by
    exact Eq.symm (mulVec_mulVec v (g⁻¹).toMatrix g.toMatrix)
  have h_combined : ((g⁻¹).toMatrix * g.toMatrix) *ᵥ v = (g⁻¹).toMatrix *ᵥ v :=
    h_assoc.trans h_apply
  -- Use the group law `g⁻¹ * g = 1` transported through `toMatrix`.
  have h_mat :
      (g⁻¹).toMatrix * g.toMatrix = (1 : Matrix (NQubitBasis n) (NQubitBasis n) ℂ) := by
    have h_inv_mul : (g⁻¹ * g : NQubitPauliGroupElement n) = 1 := by
      simpa using (NQubitPauliGroupElement.mul_left_inv g)
    have hmul : (g⁻¹ * g).toMatrix = (g⁻¹).toMatrix * g.toMatrix := by
      simpa using (toMatrix_mul (g⁻¹) g)
    calc
      (g⁻¹).toMatrix * g.toMatrix
          = (g⁻¹ * g).toMatrix := hmul.symm
      _   = (1 : NQubitPauliGroupElement n).toMatrix :=
            congrArg NQubitPauliGroupElement.toMatrix h_inv_mul
      _   = (1 : Matrix (NQubitBasis n) (NQubitBasis n) ℂ) := by
            simpa using (NQubitPauliGroupElement.toMatrix_one n)
  have h1 := h_combined
  -- Rewrite the left matrix product to the identity matrix.
  rw [h_mat] at h1
  -- Simplify `1 *ᵥ v = v`.
  have h2 : v = (g⁻¹).toMatrix *ᵥ v := by
    simpa [one_mulVec] using h1
  exact h2.symm


/-- If a state is stabilized by g, then it is stabilized by g when applied to a quantum state. -/
lemma IsStabilizedBy.state {g : NQubitPauliGroupElement n} {ψ : NQubitState n}
  (hg : IsStabilizedVec g ψ.val) :
  IsStabilizedBy g ψ := hg

/-- If a state is in the codespace, then applying any group element from the stabilizer
    group to it (via multiplication) keeps it in the codespace.

This is a key property: the codespace is invariant under the action of the stabilizer group.
-/
lemma IsInCodespace.mul {ψ : NQubitState n} {S : StabilizerGroup n}
  (h : IsInCodespace ψ S) {g : NQubitPauliGroupElement n}
  (_ : g ∈ S.toSubgroup) :
  IsInCodespace ψ S := h -- Codespace membership is independent of which element we check

/-- Alternative characterization: a state is in the codespace if and only if it is
    stabilized by all elements in the stabilizer group.

This is essentially the definition, but stated as a bidirectional equivalence for convenience.
-/
lemma IsInCodespace.iff_all_stabilizers (ψ : NQubitState n) (S : StabilizerGroup n) :
  IsInCodespace ψ S ↔ ∀ g ∈ S.toSubgroup, IsStabilizedBy g ψ :=
  Iff.rfl

/-- If a state is stabilized by g and h, then it is stabilized by g * h.

This combines `IsStabilizedBy.mul` with the subgroup property.
-/
lemma IsStabilizedBy.mul_in_group {g h : NQubitPauliGroupElement n} {ψ : NQubitState n}
  (hg_stab : IsStabilizedBy g ψ) (hh_stab : IsStabilizedBy h ψ) :
  IsStabilizedBy (g * h) ψ :=
  IsStabilizedBy.mul hg_stab hh_stab

/-- If a state is stabilized by an element, then it is also stabilized by the inverse
    of that element.

This combines `IsStabilizedBy.inv` with the subgroup property.
-/
lemma IsStabilizedBy.inv_in_group {g : NQubitPauliGroupElement n} {ψ : NQubitState n}
  (hg_stab : IsStabilizedBy g ψ) :
  IsStabilizedBy (g⁻¹) ψ :=
  IsStabilizedBy.inv hg_stab

end StabilizerGroup

end Quantum
