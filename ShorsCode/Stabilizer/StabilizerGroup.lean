import Mathlib.LinearAlgebra.Matrix.Defs
import Mathlib.LinearAlgebra.Matrix.Notation
import Mathlib.Data.Complex.Basic
import Mathlib.Tactic
import Mathlib.Algebra.Group.Defs
import Mathlib.Algebra.Group.Subgroup.Basic
import Foundations.Basic
import Foundations.Gates
import Foundations.Tensor
import ShorsCode.Stabilizer.PauliGroupSingle
import ShorsCode.Stabilizer.PauliGroup

namespace Quantum
open Matrix
open scoped BigOperators
open NQubitPauliGroupElement
open NQubitPauliOperator

variable {n : ℕ}

/-!
# Stabilizer Groups

This file defines stabilizer groups, which are abelian subgroups of the n-qubit Pauli group
that do not contain -I. Stabilizer groups are fundamental to the stabilizer formalism for
quantum error correction.

A stabilizer group stabilizes a quantum state (or subspace) by consisting of all Pauli group
elements that fix that state with eigenvalue +1.

## Key Properties

- **Abelian**: All elements in a stabilizer group commute with each other
- **No -I**: The negative identity is excluded (it would stabilize no states)
- **Subgroup structure**: Forms a subgroup of the n-qubit Pauli group
- **Codespace**: The set of states stabilized by all elements in the group forms the codespace
- **Generators**: For an n-qubit system, a stabilizer group can have at most n
independent generators

## Example

For the 3-qubit bit-flip repetition code, the stabilizer group is generated by:
- Z₁Z₂ (Z on qubits 1 and 2, I on qubit 3)
- Z₂Z₃ (I on qubit 1, Z on qubits 2 and 3)

This stabilizes the codespace spanned by |000⟩ and |111⟩.
-/

/-- The negative identity element: -I ⊗ I ⊗ ... ⊗ I.

This is the n-qubit Pauli group element with phase -1 (phasePower = 2, since
phasePower 2 corresponds to i^2 = -1) and identity operators on all qubits.

This element is excluded from stabilizer groups because it would stabilize no states
(every state would be mapped to its negative, not itself).
-/
def negIdentity (n : ℕ) : NQubitPauliGroupElement n :=
  ⟨2, NQubitPauliOperator.identity n⟩

@[simp] lemma negIdentity_phasePower (n : ℕ) : (negIdentity n).phasePower = 2 := rfl

@[simp] lemma negIdentity_operators (n : ℕ) :
  (negIdentity n).operators = NQubitPauliOperator.identity n := rfl

/-!
# Stabilized States

A quantum state is stabilized by a Pauli group element if applying that element
to the state leaves it unchanged (i.e., the state is an eigenvector
with eigenvalue +1).
-/

/-- A vector is stabilized by a Pauli group element if applying the element's matrix
    representation to the vector returns the same vector.

    This means the vector is an eigenvector with eigenvalue +1.
-/
def IsStabilizedVec (g : NQubitPauliGroupElement n) (v : NQubitVec n) : Prop :=
  Matrix.mulVec (g.toMatrix) v = v

/-- A quantum state is stabilized by a Pauli group element if its underlying vector
    is stabilized by that element.

    This means applying the Pauli group element to the state returns the same state.
-/
def IsStabilizedBy (g : NQubitPauliGroupElement n) (ψ : NQubitState n) : Prop :=
  IsStabilizedVec g ψ.val

/-- A stabilizer group is an abelian subgroup of the n-qubit Pauli group that does not contain -I.

Properties:
- It is a subgroup of the n-qubit Pauli group
- It is abelian (all elements commute)
- It does not contain -I
- For an n-qubit system, a stabilizer group can have at most n independent generators
-/
structure StabilizerGroup (n : ℕ) where
  /-- The underlying subgroup of the n-qubit Pauli group. -/
  toSubgroup : Subgroup (NQubitPauliGroupElement n)
  /-- The subgroup is abelian: all elements commute. -/
  is_abelian : ∀ (g h : NQubitPauliGroupElement n) (_ : g ∈ toSubgroup) (_ : h ∈ toSubgroup),
    g * h = h * g
  /-- The stabilizer does not contain -I. -/
  no_neg_identity : negIdentity n ∉ toSubgroup

namespace StabilizerGroup

/-- Coerce a stabilizer group to its underlying subgroup. -/
instance : Coe (StabilizerGroup n) (Subgroup (NQubitPauliGroupElement n)) :=
  ⟨StabilizerGroup.toSubgroup⟩

/-- A quantum state is in the codespace of a stabilizer group if it is stabilized
    by every element in the group.

    The codespace of a stabilizer group consists of all states stabilized by that group.
-/
def IsInCodespace (ψ : NQubitState n) (S : StabilizerGroup n) : Prop :=
  ∀ g ∈ S.toSubgroup, IsStabilizedBy g ψ

/-- The identity element is in every stabilizer group. -/
lemma one_mem (S : StabilizerGroup n) : (1 : NQubitPauliGroupElement n) ∈ S.toSubgroup :=
  S.toSubgroup.one_mem

/-- If g and h are in a stabilizer group, then g * h is also in it. -/
lemma mul_mem (S : StabilizerGroup n) {g h : NQubitPauliGroupElement n}
  (hg : g ∈ S.toSubgroup) (hh : h ∈ S.toSubgroup) : g * h ∈ S.toSubgroup :=
  S.toSubgroup.mul_mem hg hh

/-- If g is in a stabilizer group, then g⁻¹ is also in it. -/
lemma inv_mem (S : StabilizerGroup n) {g : NQubitPauliGroupElement n}
  (hg : g ∈ S.toSubgroup) : g⁻¹ ∈ S.toSubgroup :=
  S.toSubgroup.inv_mem hg

/-- All elements of a stabilizer group commute. -/
lemma commutes (S : StabilizerGroup n) {g h : NQubitPauliGroupElement n}
  (hg : g ∈ S.toSubgroup) (hh : h ∈ S.toSubgroup) : g * h = h * g :=
  S.is_abelian g h hg hh

/-- The negative identity is not in any stabilizer group. -/
lemma neg_identity_not_mem (S : StabilizerGroup n) : negIdentity n ∉ S.toSubgroup :=
  S.no_neg_identity

/-!
# Helper Lemmas for Constructing Stabilizer Groups

These lemmas make it easier to prove that a subgroup is abelian when constructing
a `StabilizerGroup`.
-/

/-!
# Basic Properties of Stabilized States
-/

/-- The identity element stabilizes all vectors. -/
lemma identity_stabilizes_vec (v : NQubitVec n) :
  IsStabilizedVec (1 : NQubitPauliGroupElement n) v := by
  simp only [IsStabilizedVec]
  rw [NQubitPauliGroupElement.toMatrix_one, one_mulVec]


/-- The identity element stabilizes all quantum states. -/
lemma identity_stabilizes (ψ : NQubitState n) : IsStabilizedBy (1 : NQubitPauliGroupElement n) ψ :=
  identity_stabilizes_vec ψ.val

/-- If a state is in the codespace of a stabilizer group, then it is stabilized by the identity. -/
lemma IsInCodespace.identity_stabilizes (ψ : NQubitState n) (S : StabilizerGroup n)
  (h : IsInCodespace ψ S) : IsStabilizedBy (1 : NQubitPauliGroupElement n) ψ := by
  have h_one : (1 : NQubitPauliGroupElement n) ∈ S.toSubgroup := S.one_mem
  exact h (1 : NQubitPauliGroupElement n) h_one

/-!
# Properties of Stabilized States

These lemmas show how stabilization behaves under group operations, which is crucial
for working with stabilizer groups and codespaces.
-/

/-- If a state is stabilized by g and h, then it is stabilized by g * h.

This follows from the fact that if g and h both fix a vector v, then their product
also fixes v: (g * h) • v = g • (h • v) = g • v = v.
-/
lemma IsStabilizedBy.mul {g h : NQubitPauliGroupElement n} {v : NQubitVec n}
  (hg : IsStabilizedVec g v) (hh : IsStabilizedVec h v) :
  IsStabilizedVec (g * h) v := by
  simp [IsStabilizedVec] at *
  -- We need: (g * h).toMatrix.mulVec v = v
  -- Using: g.toMatrix.mulVec v = v and h.toMatrix.mulVec v = v
  -- And: (g * h).toMatrix = g.toMatrix * h.toMatrix (from toMatrix_mul)
  sorry -- TODO: Requires toMatrix_mul and matrix multiplication properties

/-- If a state is stabilized by g, then it is stabilized by g⁻¹.

This follows from the fact that if g fixes v, then g⁻¹ also fixes v:
g⁻¹ • v = g⁻¹ • (g • v) = (g⁻¹ * g) • v = 1 • v = v.
-/
lemma IsStabilizedBy.inv {g : NQubitPauliGroupElement n} {v : NQubitVec n}
  (hg : IsStabilizedVec g v) :
  IsStabilizedVec (g⁻¹) v := by
  simp [IsStabilizedVec] at *
  -- We need: (g⁻¹).toMatrix.mulVec v = v
  -- Using: g.toMatrix.mulVec v = v
  -- And: (g⁻¹).toMatrix = (g.toMatrix)⁻¹ (from toMatrix_inv)
  sorry -- TODO: Requires toMatrix_inv and matrix inverse properties

/-- If a state is stabilized by g, then it is stabilized by g when applied to a quantum state. -/
lemma IsStabilizedBy.state {g : NQubitPauliGroupElement n} {ψ : NQubitState n}
  (hg : IsStabilizedVec g ψ.val) :
  IsStabilizedBy g ψ := hg

/-- If a state is in the codespace, then applying any group element from the stabilizer
    group to it (via multiplication) keeps it in the codespace.

This is a key property: the codespace is invariant under the action of the stabilizer group.
-/
lemma IsInCodespace.mul {ψ : NQubitState n} {S : StabilizerGroup n}
  (h : IsInCodespace ψ S) {g : NQubitPauliGroupElement n}
  (_ : g ∈ S.toSubgroup) :
  IsInCodespace ψ S := h -- Codespace membership is independent of which element we check

/-- Alternative characterization: a state is in the codespace if and only if it is
    stabilized by all elements in the stabilizer group.

This is essentially the definition, but stated as a bidirectional equivalence for convenience.
-/
lemma IsInCodespace.iff_all_stabilizers (ψ : NQubitState n) (S : StabilizerGroup n) :
  IsInCodespace ψ S ↔ ∀ g ∈ S.toSubgroup, IsStabilizedBy g ψ :=
  Iff.rfl

/-- If a state is stabilized by g and h, then it is stabilized by g * h.

This combines `IsStabilizedBy.mul` with the subgroup property.
-/
lemma IsStabilizedBy.mul_in_group {g h : NQubitPauliGroupElement n} {ψ : NQubitState n}
  (hg_stab : IsStabilizedBy g ψ) (hh_stab : IsStabilizedBy h ψ) :
  IsStabilizedBy (g * h) ψ :=
  IsStabilizedBy.mul hg_stab hh_stab

/-- If a state is stabilized by an element, then it is also stabilized by the inverse
    of that element.

This combines `IsStabilizedBy.inv` with the subgroup property.
-/
lemma IsStabilizedBy.inv_in_group {g : NQubitPauliGroupElement n} {ψ : NQubitState n}
  (hg_stab : IsStabilizedBy g ψ) :
  IsStabilizedBy (g⁻¹) ψ :=
  IsStabilizedBy.inv hg_stab

/-!
# The 3-Qubit Repetition Code Stabilizer Group

The 3-qubit bit-flip repetition code has stabilizer group generated by:
- Z₁Z₂: Z on qubits 0 and 1, I on qubit 2
- Z₂Z₃: I on qubit 0, Z on qubits 1 and 2

This stabilizes the codespace spanned by |000⟩ and |111⟩.
-/

namespace RepetitionCode3

/-- Z₁Z₂: Z on qubits 0 and 1, I on qubit 2. -/
def Z1Z2 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set ⟨0, by decide⟩ PauliOperator.Z).set
  ⟨1, by decide⟩ PauliOperator.Z⟩

/-- Z₂Z₃: I on qubit 0, Z on qubits 1 and 2. -/
def Z2Z3 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set ⟨1, by decide⟩ PauliOperator.Z).set
  ⟨2, by decide⟩ PauliOperator.Z⟩

/-- Z₁Z₂ and Z₂Z₃ commute.

This follows from the fact that:
- At qubit 0: Z₁Z₂ has Z, Z₂Z₃ has I → they commute
- At qubit 1: both have Z → they commute (Z commutes with Z)
- At qubit 2: Z₁Z₂ has I, Z₂Z₃ has Z → they commute
-/
lemma Z1Z2_commutes_Z2Z3 : Z1Z2 * Z2Z3 = Z2Z3 * Z1Z2 := by
  -- Use the componentwise commutation lemma from PauliGroup.lean
  have h : ∀ i : Fin 3,
  (Z1Z2.operators i).mulOp (Z2Z3.operators i) = (Z2Z3.operators i).mulOp (Z1Z2.operators i) := by
    intro i
    fin_cases i
    · -- qubit 0: Z1Z2 has Z, Z2Z3 has I → I commutes with Z
      simp [Z1Z2, Z2Z3, NQubitPauliOperator.set, NQubitPauliOperator.identity]
    · -- qubit 1: both have Z → Z commutes with Z
      simp [Z1Z2, Z2Z3, NQubitPauliOperator.set]
    · -- qubit 2: Z1Z2 has I, Z2Z3 has Z → I commutes with Z
      simp [Z1Z2, Z2Z3, NQubitPauliOperator.set, NQubitPauliOperator.identity]
  -- Now apply the commutation lemma from PauliGroup.lean

  -- So we can apply the lemma directly
  exact NQubitPauliGroupElement.commutes_of_componentwise_commutes Z1Z2 Z2Z3 h

/-- Z₁Z₂ commutes with itself (trivial but useful for completeness). -/
lemma Z1Z2_commutes_self : Z1Z2 * Z1Z2 = Z1Z2 * Z1Z2 := rfl

/-- Z₂Z₃ commutes with itself (trivial but useful for completeness). -/
lemma Z2Z3_commutes_self : Z2Z3 * Z2Z3 = Z2Z3 * Z2Z3 := rfl

/-- Z₁Z₂ has phase 0 (no global phase). -/
@[simp] lemma Z1Z2_phasePower : Z1Z2.phasePower = 0 := rfl

/-- Z₂Z₃ has phase 0 (no global phase). -/
@[simp] lemma Z2Z3_phasePower : Z2Z3.phasePower = 0 := rfl

/-- Z₁Z₂ has Z on qubit 0. -/
@[simp] lemma Z1Z2_qubit0 : Z1Z2.operators ⟨0, by decide⟩ = PauliOperator.Z := by
  simp [Z1Z2, NQubitPauliOperator.set]

/-- Z₁Z₂ has Z on qubit 1. -/
@[simp] lemma Z1Z2_qubit1 : Z1Z2.operators ⟨1, by decide⟩ = PauliOperator.Z := by
  simp [Z1Z2, NQubitPauliOperator.set]

/-- Z₁Z₂ has I on qubit 2. -/
@[simp] lemma Z1Z2_qubit2 : Z1Z2.operators ⟨2, by decide⟩ = PauliOperator.I := by
  simp [Z1Z2, NQubitPauliOperator.set, NQubitPauliOperator.identity]

/-- Z₂Z₃ has I on qubit 0. -/
@[simp] lemma Z2Z3_qubit0 : Z2Z3.operators ⟨0, by decide⟩ = PauliOperator.I := by
  simp [Z2Z3, NQubitPauliOperator.set, NQubitPauliOperator.identity]

/-- Z₂Z₃ has Z on qubit 1. -/
@[simp] lemma Z2Z3_qubit1 : Z2Z3.operators ⟨1, by decide⟩ = PauliOperator.Z := by
  simp [Z2Z3, NQubitPauliOperator.set]

/-- Z₂Z₃ has Z on qubit 2. -/
@[simp] lemma Z2Z3_qubit2 : Z2Z3.operators ⟨2, by decide⟩ = PauliOperator.Z := by
  simp [Z2Z3, NQubitPauliOperator.set]

/-- Z₁Z₂ squared equals the identity (since Z * Z = I). -/
lemma Z1Z2_sq : Z1Z2 * Z1Z2 = 1 := by
  -- Z1Z2 has phase 0, so Z1Z2⁻¹ = Z1Z2 (inverse just negates phase, and -0 = 0)
  -- So Z1Z2 * Z1Z2 = Z1Z2 * Z1Z2⁻¹ = 1
  have h_inv : Z1Z2⁻¹ = Z1Z2 := by
    simp [Z1Z2, NQubitPauliGroupElement.inv]
  rw [← h_inv]
  exact NQubitPauliGroupElement.mul_right_inv Z1Z2

/-- Z₂Z₃ squared equals the identity (since Z * Z = I). -/
lemma Z2Z3_sq : Z2Z3 * Z2Z3 = 1 := by
  -- Similar to Z1Z2_sq
  have h_inv : Z2Z3⁻¹ = Z2Z3 := by
    simp [Z2Z3, NQubitPauliGroupElement.inv]
  rw [← h_inv]
  exact NQubitPauliGroupElement.mul_right_inv Z2Z3

/-- The product Z₁Z₂ * Z₂Z₃ has phase 0. -/
lemma Z1Z2_mul_Z2Z3_phase : (Z1Z2 * Z2Z3).phasePower = 0 := by
  -- Both Z1Z2 and Z2Z3 have phase 0, and all qubit multiplications contribute phase 0
  -- qubit 0: Z * I = Z (phase 0), qubit 1: Z * Z = I (phase 0), qubit 2: I * Z = Z (phase 0)
  -- So total phase is 0
  sorry -- TODO: Prove phase sum is 0 (requires internal mulOp phase calculation)

/-- The product Z₁Z₂ * Z₂Z₃: Z on qubits 0 and 2, I on qubit 1. -/
lemma Z1Z2_mul_Z2Z3_operators :
  (Z1Z2 * Z2Z3).operators =
    ((NQubitPauliOperator.identity 3).set ⟨0, by decide⟩ PauliOperator.Z).set
      ⟨2, by decide⟩ PauliOperator.Z := by
  -- Z1Z2 has Z on qubits 0,1; I on qubit 2
  -- Z2Z3 has I on qubit 0; Z on qubits 1,2
  -- Product: qubit 0: Z * I = Z, qubit 1: Z * Z = I, qubit 2: I * Z = Z
  -- The multiplication computes qubit-by-qubit: (p i).mulOp (q i)
  sorry -- TODO: Prove operator calculation (requires internal mulOp structure)
end RepetitionCode3

end StabilizerGroup

end Quantum
