import Mathlib.Tactic
import ShorsCode.Stabilizer.StabilizerGroup
import ShorsCode.Stabilizer.SubgroupLemmas
import ShorsCode.Stabilizer.CSSNoNegI
import ShorsCode.Stabilizer.PauliGroup.Commutation

namespace Quantum
open scoped BigOperators

namespace StabilizerGroup
namespace Steane7

/-!
# The Steane [[7,1,3]] code (CSS stabilizer generators)

We use the standard CSS presentation coming from the classical [7,4,3] Hamming code.

Let the parity-check rows (supports) be:
- r₁ = {0,1,2,4}
- r₂ = {0,1,3,5}
- r₃ = {0,2,3,6}

Then the Steane stabilizer is generated by:
- Z-checks: Z on each row support (3 generators)
- X-checks: X on each row support (3 generators)

Cross-commutation holds because every Z-row intersects every X-row in an even number of qubits.
We package the resulting subgroup as a `StabilizerGroup 7`.
-/

open NQubitPauliGroupElement

/-!
## Generators
-/

def Z1 : NQubitPauliGroupElement 7 :=
  ⟨0,
    (((NQubitPauliOperator.identity 7).set 0 PauliOperator.Z).set 1 PauliOperator.Z).set 2
      PauliOperator.Z |>.set 4 PauliOperator.Z⟩

def Z2 : NQubitPauliGroupElement 7 :=
  ⟨0,
    (((NQubitPauliOperator.identity 7).set 0 PauliOperator.Z).set 1 PauliOperator.Z).set 3
      PauliOperator.Z |>.set 5 PauliOperator.Z⟩

def Z3 : NQubitPauliGroupElement 7 :=
  ⟨0,
    (((NQubitPauliOperator.identity 7).set 0 PauliOperator.Z).set 2 PauliOperator.Z).set 3
      PauliOperator.Z |>.set 6 PauliOperator.Z⟩

def X1 : NQubitPauliGroupElement 7 :=
  ⟨0,
    (((NQubitPauliOperator.identity 7).set 0 PauliOperator.X).set 1 PauliOperator.X).set 2
      PauliOperator.X |>.set 4 PauliOperator.X⟩

def X2 : NQubitPauliGroupElement 7 :=
  ⟨0,
    (((NQubitPauliOperator.identity 7).set 0 PauliOperator.X).set 1 PauliOperator.X).set 3
      PauliOperator.X |>.set 5 PauliOperator.X⟩

def X3 : NQubitPauliGroupElement 7 :=
  ⟨0,
    (((NQubitPauliOperator.identity 7).set 0 PauliOperator.X).set 2 PauliOperator.X).set 3
      PauliOperator.X |>.set 6 PauliOperator.X⟩

def ZGenerators : Set (NQubitPauliGroupElement 7) :=
  {Z1, Z2, Z3}

def XGenerators : Set (NQubitPauliGroupElement 7) :=
  {X1, X2, X3}

def generators : Set (NQubitPauliGroupElement 7) :=
  ZGenerators ∪ XGenerators

def subgroup : Subgroup (NQubitPauliGroupElement 7) :=
  Subgroup.closure generators

/-!
## Typing facts: Z-type / X-type generators
-/

lemma ZGenerators_are_ZType :
    ∀ g, g ∈ ZGenerators → NQubitPauliGroupElement.IsZTypeElement g := by
  classical
  intro g hg
  rcases (by simpa [ZGenerators] using hg) with rfl | rfl | rfl <;>
    · constructor
      · rfl
      · intro i
        fin_cases i <;>
          simp [PauliOperator.IsZType, Z1, Z2, Z3, NQubitPauliOperator.set,
            NQubitPauliOperator.identity]

lemma XGenerators_are_XType :
    ∀ g, g ∈ XGenerators → NQubitPauliGroupElement.IsXTypeElement g := by
  classical
  intro g hg
  rcases (by simpa [XGenerators] using hg) with rfl | rfl | rfl <;>
    · constructor
      · rfl
      · intro i
        fin_cases i <;>
          simp [PauliOperator.IsXType, X1, X2, X3, NQubitPauliOperator.set,
            NQubitPauliOperator.identity]

/-!
## Cross-commutation: Z generators commute with X generators

We use `commutes_iff_even_anticommutes` and compute the anticommute set explicitly.
-/

private lemma commute_by_even_anticommutes (z x : NQubitPauliGroupElement 7)
    (hEven :
      (by
        classical
        exact Even
          ((Finset.univ.filter
                (NQubitPauliGroupElement.anticommutesAt (n := 7) z.operators x.operators)).card))) :
    z * x = x * z :=
  (NQubitPauliGroupElement.commutes_iff_even_anticommutes z x).2 hEven

private lemma Z1_comm_X1 : Z1 * X1 = X1 * Z1 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z1.operators X1.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 1, 2, 4} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z1, X1, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simpa [hfilter] using (by decide : Even (4 : Nat))
  exact commute_by_even_anticommutes Z1 X1 (by simpa [p] using hEven)

private lemma Z1_comm_X2 : Z1 * X2 = X2 * Z1 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z1.operators X2.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 1} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z1, X2, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simp [hfilter]
  exact commute_by_even_anticommutes Z1 X2 (by simpa [p] using hEven)

private lemma Z1_comm_X3 : Z1 * X3 = X3 * Z1 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z1.operators X3.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 2} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z1, X3, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simp [hfilter]
  exact commute_by_even_anticommutes Z1 X3 (by simpa [p] using hEven)

private lemma Z2_comm_X1 : Z2 * X1 = X1 * Z2 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z2.operators X1.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 1} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z2, X1, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simp [hfilter]
  exact commute_by_even_anticommutes Z2 X1 (by simpa [p] using hEven)

private lemma Z2_comm_X2 : Z2 * X2 = X2 * Z2 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z2.operators X2.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 1, 3, 5} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z2, X2, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simpa [hfilter] using (by decide : Even (4 : Nat))
  exact commute_by_even_anticommutes Z2 X2 (by simpa [p] using hEven)

private lemma Z2_comm_X3 : Z2 * X3 = X3 * Z2 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z2.operators X3.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 3} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z2, X3, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simp [hfilter]
  exact commute_by_even_anticommutes Z2 X3 (by simpa [p] using hEven)

private lemma Z3_comm_X1 : Z3 * X1 = X1 * Z3 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z3.operators X1.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 2} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z3, X1, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simp [hfilter]
  exact commute_by_even_anticommutes Z3 X1 (by simpa [p] using hEven)

private lemma Z3_comm_X2 : Z3 * X2 = X2 * Z3 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z3.operators X2.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 3} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z3, X2, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simp [hfilter]
  exact commute_by_even_anticommutes Z3 X2 (by simpa [p] using hEven)

private lemma Z3_comm_X3 : Z3 * X3 = X3 * Z3 := by
  classical
  let p : Fin 7 → Prop :=
    NQubitPauliGroupElement.anticommutesAt (n := 7) Z3.operators X3.operators
  have hfilter :
      (Finset.univ.filter p) =
        ({0, 2, 3, 6} : Finset (Fin 7)) := by
    ext i; fin_cases i <;>
      simp [p, NQubitPauliGroupElement.anticommutesAt, Z3, X3, NQubitPauliOperator.set,
        NQubitPauliOperator.identity, PauliOperator.mulOp]
  have hEven :
      Even ((Finset.univ.filter p).card) := by
    simpa [hfilter] using (by decide : Even (4 : Nat))
  exact commute_by_even_anticommutes Z3 X3 (by simpa [p] using hEven)

lemma ZGenerators_commute_XGenerators :
    ∀ z ∈ ZGenerators, ∀ x ∈ XGenerators, z * x = x * z := by
  classical
  intro z hz x hx
  rcases (by simpa [ZGenerators] using hz) with rfl | rfl | rfl <;>
    rcases (by simpa [XGenerators] using hx) with rfl | rfl | rfl
  · exact Z1_comm_X1
  · exact Z1_comm_X2
  · exact Z1_comm_X3
  · exact Z2_comm_X1
  · exact Z2_comm_X2
  · exact Z2_comm_X3
  · exact Z3_comm_X1
  · exact Z3_comm_X2
  · exact Z3_comm_X3

/-!
## Pairwise commutation of all generators
-/

private lemma ZType_commutes {g h : NQubitPauliGroupElement 7}
    (hg : NQubitPauliGroupElement.IsZTypeElement g)
    (hh : NQubitPauliGroupElement.IsZTypeElement h) :
    g * h = h * g := by
  classical
  apply NQubitPauliGroupElement.commutes_of_componentwise_commutes
  intro i
  have hg' := hg.2 i
  have hh' := hh.2 i
  rcases hg' with hgI | hgZ <;> rcases hh' with hhI | hhZ
  · simp [PauliOperator.mulOp, hgI, hhI]
  · simp [PauliOperator.mulOp, hgI, hhZ]
  · simp [PauliOperator.mulOp, hgZ, hhI]
  · simp [PauliOperator.mulOp, hgZ, hhZ]

private lemma XType_commutes {g h : NQubitPauliGroupElement 7}
    (hg : NQubitPauliGroupElement.IsXTypeElement g)
    (hh : NQubitPauliGroupElement.IsXTypeElement h) :
    g * h = h * g := by
  classical
  apply NQubitPauliGroupElement.commutes_of_componentwise_commutes
  intro i
  have hg' := hg.2 i
  have hh' := hh.2 i
  rcases hg' with hgI | hgX <;> rcases hh' with hhI | hhX
  · simp [PauliOperator.mulOp, hgI, hhI]
  · simp [PauliOperator.mulOp, hgI, hhX]
  · simp [PauliOperator.mulOp, hgX, hhI]
  · simp [PauliOperator.mulOp, hgX, hhX]

theorem generators_commute :
    ∀ g ∈ generators, ∀ h ∈ generators, g * h = h * g := by
  classical
  intro g hg h hh
  have hg' : g ∈ ZGenerators ∨ g ∈ XGenerators := by simpa [generators] using hg
  have hh' : h ∈ ZGenerators ∨ h ∈ XGenerators := by simpa [generators] using hh
  rcases hg' with hgZ | hgX <;> rcases hh' with hhZ | hhX
  · exact ZType_commutes (ZGenerators_are_ZType g hgZ) (ZGenerators_are_ZType h hhZ)
  · exact ZGenerators_commute_XGenerators g hgZ h hhX
  · simpa using (ZGenerators_commute_XGenerators h hhZ g hgX).symm
  · exact XType_commutes (XGenerators_are_XType g hgX) (XGenerators_are_XType h hhX)

/-!
## No `-I` in the Steane stabilizer subgroup (CSS lemma)
-/

theorem negIdentity_not_mem :
    negIdentity 7 ∉ subgroup := by
  have hZX : ∀ z ∈ ZGenerators, ∀ x ∈ XGenerators, z * x = x * z :=
    ZGenerators_commute_XGenerators
  simpa [subgroup, generators] using
    (CSS.negIdentity_not_mem_closure_union (n := 7) ZGenerators XGenerators
      ZGenerators_are_ZType XGenerators_are_XType hZX)

/-!
## Bundled `StabilizerGroup 7`
-/

noncomputable def stabilizerGroup : StabilizerGroup 7 :=
{ toSubgroup := subgroup
, is_abelian := by
    intro g h hg hh
    have hcomm :=
      Subgroup.abelian_closure_of_pairwise_commute (G := NQubitPauliGroupElement 7)
        generators generators_commute
    simpa [subgroup] using hcomm g (by simpa [subgroup] using hg) h (by simpa [subgroup] using hh)
, no_neg_identity := by
    simpa using negIdentity_not_mem }

end Steane7
end StabilizerGroup

end Quantum
