import ShorsCode.Stabilizer.PauliGroup.Commutation
import ShorsCode.Stabilizer.Core.StabilizerGroup
import ShorsCode.Stabilizer.Core.SubgroupLemmas
import ShorsCode.Stabilizer.Core.CSSNoNegI

namespace Quantum
open scoped BigOperators

namespace StabilizerGroup
namespace RepetitionCode3

/-- Z₁Z₂: Z on qubits 0 and 1, I on qubit 2. -/
def Z1Z2 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 0 PauliOperator.Z).set 1 PauliOperator.Z⟩

/-- Z₂Z₃: I on qubit 0, Z on qubits 1 and 2. -/
def Z2Z3 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 1 PauliOperator.Z).set 2 PauliOperator.Z⟩

/-- The generator set for the 3-qubit repetition-code stabilizer subgroup. -/
def generators : Set (NQubitPauliGroupElement 3) :=
  {Z1Z2, Z2Z3}

/-- The generators commute (proved componentwise). -/
lemma Z1Z2_commutes_Z2Z3 : Z1Z2 * Z2Z3 = Z2Z3 * Z1Z2 := by
  classical
  -- Use the general componentwise-commutation lemma for n-qubit Pauli elements.
  apply NQubitPauliGroupElement.commutes_of_componentwise_commutes
  intro i
  fin_cases i <;>
    simp [Z1Z2, Z2Z3, NQubitPauliOperator.set, NQubitPauliOperator.identity]

/-- Pairwise commutation for elements of `generators`. -/
theorem generators_commute :
    ∀ g ∈ generators, ∀ h ∈ generators, g * h = h * g := by
  classical
  intro g hg h hh
  simp [generators] at hg hh
  rcases hg with rfl | rfl <;> rcases hh with rfl | rfl
  · rfl
  · exact Z1Z2_commutes_Z2Z3
  · simpa using Z1Z2_commutes_Z2Z3.symm
  · rfl

/-- The subgroup generated by the repetition-code generators. -/
def subgroup : Subgroup (NQubitPauliGroupElement 3) :=
  Subgroup.closure generators

/-- Example usage: the generated subgroup is abelian, via `SubgroupLemmas`. -/
theorem subgroup_is_abelian :
    ∀ g ∈ subgroup, ∀ h ∈ subgroup, g * h = h * g := by
  -- `subgroup` is definitionaly `Subgroup.closure generators`.
  simpa [subgroup] using
    (Subgroup.abelian_closure_of_pairwise_commute (G := NQubitPauliGroupElement 3)
      generators generators_commute)

/-!
## No `-I` in the generated subgroup

This is a special case of the reusable CSS lemma with:
- Z-generators = `generators`
- X-generators = `∅`
-/

open NQubitPauliGroupElement

lemma generators_are_ZType :
    ∀ g, g ∈ generators → NQubitPauliGroupElement.IsZTypeElement g := by
  classical
  intro g hg
  rcases (by simpa [generators] using hg) with rfl | rfl <;>
    · constructor
      · rfl
      · intro i
        fin_cases i <;>
          simp [PauliOperator.IsZType, Z1Z2, Z2Z3, NQubitPauliOperator.set,
            NQubitPauliOperator.identity]

lemma negIdentity_not_mem :
    negIdentity 3 ∉ subgroup := by
  -- Apply the generic CSS `-I` exclusion theorem with empty X-generators.
  have hX : ∀ x, x ∈ (∅ : Set (NQubitPauliGroupElement 3)) → IsXTypeElement x := by
    intro x hx; cases hx
  have hZX : ∀ z ∈ generators, ∀ x ∈ (∅ : Set (NQubitPauliGroupElement 3)), z * x = x * z := by
    intro z hz x hx; cases hx
  simpa [subgroup] using
    (CSS.negIdentity_not_mem_closure_union (n := 3) generators (∅ : Set (NQubitPauliGroupElement 3))
      generators_are_ZType hX hZX)

noncomputable def stabilizerGroup : StabilizerGroup 3 :=
{ toSubgroup := subgroup
, is_abelian := by
    intro g h hg hh
    exact subgroup_is_abelian g hg h hh
, no_neg_identity := by
    simpa using negIdentity_not_mem }

end RepetitionCode3
end StabilizerGroup

end Quantum

