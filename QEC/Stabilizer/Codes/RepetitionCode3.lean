import QEC.Stabilizer.PauliGroup.Commutation
import QEC.Stabilizer.PauliGroup.CommutationTactics
import QEC.Stabilizer.Core.StabilizerGroup
import QEC.Stabilizer.Core.SubgroupLemmas
import QEC.Stabilizer.Core.CSSNoNegI
import QEC.Stabilizer.Core.Centralizer
import QEC.Stabilizer.PauliGroup.NQubitOperator

namespace Quantum
open scoped BigOperators

namespace StabilizerGroup
namespace RepetitionCode3

/-- Z₁Z₂: Z on qubits 0 and 1, I on qubit 2. -/
def Z1Z2 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 0 PauliOperator.Z).set 1 PauliOperator.Z⟩

/-- Z₂Z₃: I on qubit 0, Z on qubits 1 and 2. -/
def Z2Z3 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 1 PauliOperator.Z).set 2 PauliOperator.Z⟩

/-- The generator set for the 3-qubit repetition-code stabilizer subgroup. -/
def generators : Set (NQubitPauliGroupElement 3) :=
  {Z1Z2, Z2Z3}

/-- The generators commute (proved componentwise). -/
lemma Z1Z2_commutes_Z2Z3 : Z1Z2 * Z2Z3 = Z2Z3 * Z1Z2 := by
  pauli_comm_componentwise [Z1Z2, Z2Z3]

/-- Pairwise commutation for elements of `generators`. -/
theorem generators_commute :
    ∀ g ∈ generators, ∀ h ∈ generators, g * h = h * g := by
  classical
  intro g hg h hh
  simp [generators] at hg hh
  rcases hg with rfl | rfl <;> rcases hh with rfl | rfl
  · rfl
  · exact Z1Z2_commutes_Z2Z3
  · simpa using Z1Z2_commutes_Z2Z3.symm
  · rfl

/-- The subgroup generated by the repetition-code generators. -/
def subgroup : Subgroup (NQubitPauliGroupElement 3) :=
  Subgroup.closure generators

/-- Example usage: the generated subgroup is abelian, via `SubgroupLemmas`. -/
theorem subgroup_is_abelian :
    ∀ g ∈ subgroup, ∀ h ∈ subgroup, g * h = h * g := by
  -- `subgroup` is definitionaly `Subgroup.closure generators`.
  simpa [subgroup] using
    (Subgroup.abelian_closure_of_pairwise_commute (G := NQubitPauliGroupElement 3)
      generators generators_commute)

/-!
## No `-I` in the generated subgroup

This is a special case of the reusable CSS lemma with:
- Z-generators = `generators`
- X-generators = `∅`
-/

open NQubitPauliGroupElement

lemma generators_are_ZType :
    ∀ g, g ∈ generators → NQubitPauliGroupElement.IsZTypeElement g := by
  classical
  intro g hg
  rcases (by simpa [generators] using hg) with rfl | rfl <;>
    · constructor
      · rfl
      · intro i
        fin_cases i <;>
          simp [PauliOperator.IsZType, Z1Z2, Z2Z3, NQubitPauliOperator.set,
            NQubitPauliOperator.identity]

lemma negIdentity_not_mem :
    negIdentity 3 ∉ subgroup := by
  -- Apply the generic CSS `-I` exclusion theorem with empty X-generators.
  have hX : ∀ x, x ∈ (∅ : Set (NQubitPauliGroupElement 3)) → IsXTypeElement x := by
    intro x hx; cases hx
  have hZX : ∀ z ∈ generators, ∀ x ∈ (∅ : Set (NQubitPauliGroupElement 3)), z * x = x * z := by
    intro z hz x hx; cases hx
  simpa [subgroup] using
    (CSS.negIdentity_not_mem_closure_union (n := 3) generators (∅ : Set (NQubitPauliGroupElement 3))
      generators_are_ZType hX hZX)

noncomputable def stabilizerGroup : StabilizerGroup 3 :=
{ toSubgroup := subgroup
, is_abelian := by
    intro g h hg hh
    exact subgroup_is_abelian g hg h hh
, no_neg_identity := by
    simpa using negIdentity_not_mem }

/-!
## Logical operators
-/

/-- Logical X: X on all three qubits. -/
def logicalX : NQubitPauliGroupElement 3 :=
  ⟨0, NQubitPauliOperator.X 3⟩

/-- Logical Z: Z on qubit 0 only. -/
def logicalZ : NQubitPauliGroupElement 3 :=
  ⟨0, (NQubitPauliOperator.identity 3).set 0 PauliOperator.Z⟩

private lemma logicalX_commutes_Z1Z2 : logicalX * Z1Z2 = Z1Z2 * logicalX := by
  classical
  pauli_comm_even_anticommutes
  have hfilter :
      (Finset.univ.filter
            (NQubitPauliGroupElement.anticommutesAt (n := 3) logicalX.operators Z1Z2.operators)) =
        ({0, 1} : Finset (Fin 3)) := by
    ext i; fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, logicalX, Z1Z2,
        NQubitPauliOperator.X, NQubitPauliOperator.set, NQubitPauliOperator.identity,
        PauliOperator.mulOp]
  simp [hfilter]

private lemma logicalX_commutes_Z2Z3 : logicalX * Z2Z3 = Z2Z3 * logicalX := by
  classical
  pauli_comm_even_anticommutes
  have hfilter :
      (Finset.univ.filter
            (NQubitPauliGroupElement.anticommutesAt (n := 3) logicalX.operators Z2Z3.operators)) =
        ({1, 2} : Finset (Fin 3)) := by
    ext i; fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, logicalX, Z2Z3,
        NQubitPauliOperator.X, NQubitPauliOperator.set, NQubitPauliOperator.identity,
        PauliOperator.mulOp]
  simp [hfilter]

theorem logicalX_mem_centralizer : logicalX ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * logicalX = logicalX * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact logicalX_commutes_Z1Z2.symm
    · exact logicalX_commutes_Z2Z3.symm
  · calc (x * y) * logicalX = x * (y * logicalX) := by rw [NQubitPauliGroupElement.mul_assoc]
    _ = x * (logicalX * y) := by rw [hy]
    _ = (x * logicalX) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
    _ = (logicalX * x) * y := by rw [hx]
    _ = logicalX * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * logicalX) * x = (logicalX * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

lemma logicalX_is_XType : NQubitPauliGroupElement.IsXTypeElement logicalX := by
  constructor
  · rfl
  · intro i
    fin_cases i <;> simp [logicalX, NQubitPauliOperator.X, PauliOperator.IsXType]

/-- The subgroup has exactly four elements: 1, Z1Z2, Z2Z3, Z1Z2*Z2Z3. -/
private lemma subgroup_elems (g : NQubitPauliGroupElement 3) (hg : g ∈ subgroup) :
    g = 1 ∨ g = Z1Z2 ∨ g = Z2Z3 ∨ g = Z1Z2 * Z2Z3 := by
  refine Subgroup.closure_induction (p := fun x _ => x = 1 ∨ x = Z1Z2 ∨ x = Z2Z3 ∨ x = Z1Z2 * Z2Z3)
    (fun g hg' => ?_) (by left; rfl) (fun x y _ _ => ?_) (fun x _ => ?_) hg
  · simp [generators] at hg'
    rcases hg' with rfl | rfl
    · right; left; rfl
    · right; right; left; rfl
  · rintro ( rfl | rfl | rfl | rfl ) ( rfl | rfl | rfl | rfl ) <;> simp +decide [ * ];
    all_goals simp_all +decide [ eq_comm, NQubitPauliGroupElement.ext_iff,
    NQubitPauliOperator.ext_iff ]
  · rintro hx'
    rcases hx' with rfl | rfl | rfl | rfl
    · left; rfl
    · right; left; simp [Z1Z2, NQubitPauliGroupElement.inv_eq, NQubitPauliGroupElement.inv]
    · right; right; left; simp [Z2Z3, NQubitPauliGroupElement.inv_eq, NQubitPauliGroupElement.inv]
    · right; right; right; rw [mul_inv_rev]
      have h2 : (Z2Z3)⁻¹ = Z2Z3 := by simp [Z2Z3,
      NQubitPauliGroupElement.inv_eq, NQubitPauliGroupElement.inv]
      have h3 : (Z1Z2)⁻¹ = Z1Z2 := by simp [Z1Z2,
      NQubitPauliGroupElement.inv_eq, NQubitPauliGroupElement.inv]
      rw [h2, h3, Z1Z2_commutes_Z2Z3]

theorem logicalX_not_mem_subgroup : logicalX ∉ subgroup := by
  -- By definition of subgroup, if logicalX were in the subgroup, it would have
  -- to be one of the elements 1, Z1Z2, Z2Z3, or Z1Z2*Z2Z3.
  have h_cases : ∀ g ∈ subgroup, g = 1 ∨ g = Z1Z2 ∨ g = Z2Z3 ∨ g = Z1Z2 * Z2Z3 := by
    -- Apply the lemma that states any element in the subgroup is one of the four elements.
    apply subgroup_elems;
  -- By checking each element in the subgroup, we can see that logicalX is not equal to any of them.
  have h_not_in_subgroup : logicalX ≠ 1 ∧ logicalX ≠ Z1Z2 ∧ logicalX ≠ Z2Z3 ∧
  logicalX ≠ Z1Z2 * Z2Z3 := by
    simp +decide [ NQubitPauliGroupElement.ext_iff, NQubitPauliOperator.ext_iff ];
  intros h_mem
  have h_eq : logicalX = 1 ∨ logicalX = Z1Z2 ∨ logicalX = Z2Z3 ∨ logicalX =
  Z1Z2 * Z2Z3 := h_cases logicalX h_mem
  exact h_not_in_subgroup.left (by tauto)

private lemma logicalZ_commutes_Z1Z2 : logicalZ * Z1Z2 = Z1Z2 * logicalZ := by
  pauli_comm_componentwise [logicalZ, Z1Z2]

private lemma logicalZ_commutes_Z2Z3 : logicalZ * Z2Z3 = Z2Z3 * logicalZ := by
  pauli_comm_componentwise [logicalZ, Z2Z3]

theorem logicalZ_mem_centralizer : logicalZ ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * logicalZ = logicalZ * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact logicalZ_commutes_Z1Z2.symm
    · exact logicalZ_commutes_Z2Z3.symm
  · calc (x * y) * logicalZ = x * (y * logicalZ) := by rw [NQubitPauliGroupElement.mul_assoc]
    _ = x * (logicalZ * y) := by rw [hy]
    _ = (x * logicalZ) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
    _ = (logicalZ * x) * y := by rw [hx]
    _ = logicalZ * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * logicalZ) * x = (logicalZ * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

theorem logicalZ_not_mem_subgroup : logicalZ ∉ subgroup := by
  have h_subgroup : ∀ g ∈ Quantum.StabilizerGroup.RepetitionCode3.subgroup, g =
  1 ∨ g = Z1Z2 ∨ g = Z2Z3 ∨ g = Z1Z2 * Z2Z3 := by
    intro g hg
    apply subgroup_elems g hg;
  contrapose! h_subgroup;
  refine ⟨ logicalZ, h_subgroup, ?_, ?_, ?_, ?_ ⟩
  all_goals simp +decide [ NQubitPauliGroupElement.ext_iff ];
  · exact fun h => by have := congr_fun h 0; simp +decide at this;
  · simp +decide [ NQubitPauliOperator.ext_iff ];
  · simp +decide [ NQubitPauliOperator.ext_iff ];
  · simp +decide [ NQubitPauliOperator.ext_iff ]

end RepetitionCode3
end StabilizerGroup

end Quantum
